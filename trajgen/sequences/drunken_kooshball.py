"""
Defines the DrunkenKooshballSequence class.
"""
from typing import Any, Dict, Optional, Tuple, Union

import numpy as np

from trajgen.generators import generate_drunken_kooshball_trajectory
from trajgen.sequence_base import MRISequence
from trajgen.trajectory import COMMON_NUCLEI_GAMMA_HZ_PER_T

__all__ = ['DrunkenKooshballSequence']


class DrunkenKooshballSequence(MRISequence):
    """
    Represents a 3D "Drunken Kooshball" k-space trajectory.

    This sequence is generated by perturbing a base 3D spherical spiral trajectory
    and then iteratively smoothing it to attempt to meet gradient and slew rate
    constraints. It's designed for pseudo-random, variable-density 3D k-space coverage.
    """

    def __init__(self,
                 # Common MRISequence parameters (some are also for generator)
                 name: str,
                 fov_mm: Union[float, Tuple[float, float, float]],
                 resolution_mm: Union[float, Tuple[float, float, float]],
                 dt_seconds: float,
                 # Drunken Kooshball specific parameters (also for generator)
                 num_points: int, # Total number of points for the trajectory
                 base_spherical_spiral_turns: float = 10.0,
                 perturbation_amplitude_factor: float = 0.1,
                 density_sigma_factor: float = 0.25,
                 max_grad_Tm_per_m: Optional[float] = None, # Target for generator
                 max_slew_Tm_per_s_per_m: Optional[float] = None, # Target for generator (T/m/s)
                 num_smoothing_iterations: int = 3,
                 smoothing_kernel_size: int = 5,
                 smoothness_emphasis_factor: Optional[float] = None, # New
                 # Other MRISequence parameters
                 gamma_Hz_per_T: float = COMMON_NUCLEI_GAMMA_HZ_PER_T['1H'],
                 dead_time_start_seconds: float = 0.0,
                 dead_time_end_seconds: float = 0.0,
                 metadata: Optional[Dict[str, Any]] = None):
        """
        Initializes a DrunkenKooshballSequence object.

        Args:
            name (str): Name of the sequence.
            fov_mm (Union[float, Tuple[float,float,float]]): Field of View in mm.
            resolution_mm (Union[float, Tuple[float,float,float]]): Desired resolution in mm.
            dt_seconds (float): Dwell time (time between k-space samples) in seconds.
            num_points (int): Total number of k-space points for the trajectory.
            base_spherical_spiral_turns (float): Turns for the base spherical spiral's phi component.
            perturbation_amplitude_factor (float): Factor scaling random noise amplitude.
            density_sigma_factor (float): Sigma for Gaussian weighting of noise (relative to k_max).
            max_grad_Tm_per_m (Optional[float]): Target maximum gradient for generator (T/m).
            max_slew_Tm_per_s_per_m (Optional[float]): Target maximum slew rate for generator (T/m/s).
            num_smoothing_iterations (int): Iterations for smoothing in generator.
            smoothing_kernel_size (int): Kernel size for smoothing in generator.
            smoothness_emphasis_factor (Optional[float]): Factor [0,1] to emphasize smoothness.
            gamma_Hz_per_T (float): Gyromagnetic ratio.
            dead_time_start_seconds (float): Dead time at sequence start.
            dead_time_end_seconds (float): Dead time at sequence end.
            metadata (Optional[Dict[str, Any]]): Additional metadata.
        """
        self.num_points = num_points
        self.base_spherical_spiral_turns = base_spherical_spiral_turns
        self.perturbation_amplitude_factor = perturbation_amplitude_factor
        self.density_sigma_factor = density_sigma_factor
        self.gen_max_grad_Tm_per_m = max_grad_Tm_per_m
        self.gen_max_slew_Tm_per_s_per_m = max_slew_Tm_per_s_per_m
        self.num_smoothing_iterations = num_smoothing_iterations
        self.smoothing_kernel_size = smoothing_kernel_size
        self.smoothness_emphasis_factor = smoothness_emphasis_factor # New

        sequence_specific_params = {
            'num_points': num_points,
            'base_spherical_spiral_turns': base_spherical_spiral_turns,
            'perturbation_amplitude_factor': perturbation_amplitude_factor,
            'density_sigma_factor': density_sigma_factor,
            'max_grad_Tm_per_m_target': max_grad_Tm_per_m,
            'max_slew_Tm_per_s_per_m_target': max_slew_Tm_per_s_per_m,
            'num_smoothing_iterations': num_smoothing_iterations,
            'smoothing_kernel_size': smoothing_kernel_size,
            'smoothness_emphasis_factor': smoothness_emphasis_factor, # New
        }

        num_dimensions = 3 # Drunken Kooshball is 3D

        super().__init__(
            name=name,
            fov_mm=fov_mm,
            resolution_mm=resolution_mm,
            num_dimensions=num_dimensions,
            dt_seconds=dt_seconds,
            gamma_Hz_per_T=gamma_Hz_per_T,
            sequence_specific_params=sequence_specific_params,
            dead_time_start_seconds=dead_time_start_seconds,
            dead_time_end_seconds=dead_time_end_seconds,
            metadata=metadata
        )

    def _generate_kspace_points(self) -> np.ndarray:
        """
        Generates k-space points for the Drunken Kooshball sequence.
        The generator returns k-space points in rad/m with shape (3, N).
        """
        kspace_points_D_N = generate_drunken_kooshball_trajectory(
            fov_mm=self.fov_mm,
            resolution_mm=self.resolution_mm,
            num_points=self.num_points,
            dt_seconds=self.dt_seconds,
            base_spherical_spiral_turns=self.base_spherical_spiral_turns,
            perturbation_amplitude_factor=self.perturbation_amplitude_factor,
            density_sigma_factor=self.density_sigma_factor,
            max_grad_Tm_per_m=self.gen_max_grad_Tm_per_m,
            max_slew_Tm_per_s_per_m=self.gen_max_slew_Tm_per_s_per_m,
            gamma_Hz_per_T=self.metadata.get('gamma_Hz_per_T', COMMON_NUCLEI_GAMMA_HZ_PER_T['1H']),
            num_smoothing_iterations=self.num_smoothing_iterations,
            smoothing_kernel_size=self.smoothing_kernel_size,
            smoothness_emphasis_factor=self.smoothness_emphasis_factor # New
        )
        return kspace_points_D_N

    def check_gradient_limits(self, system_limits: Dict[str, Any]) -> bool:
        max_grad_limit_Tm_per_m = system_limits.get('max_grad_Tm_per_m')
        max_slew_limit_Tm_per_s = system_limits.get('max_slew_Tm_per_s_per_m')

        actual_max_grad_Tm = self.get_max_grad_Tm()
        actual_max_slew_Tm_per_s = self.get_max_slew_Tm_per_s()
        grad_ok, slew_ok = True, True
        print_prefix = f"Gradient Limit Check for '{self.name}':"

        if actual_max_grad_Tm is None: grad_ok = False; print(f"{print_prefix} Could not determine actual max gradient.")
        elif max_grad_limit_Tm_per_m is not None:
            grad_ok = actual_max_grad_Tm <= max_grad_limit_Tm_per_m
            print(f"{print_prefix} Max Gradient: {actual_max_grad_Tm:.4f} T/m. Limit: {max_grad_limit_Tm_per_m:.4f} T/m. Status: {'OK' if grad_ok else 'EXCEEDED'}")
        else: print(f"{print_prefix} Max Gradient: {actual_max_grad_Tm:.4f} T/m. No runtime limit provided for gradient.")

        if actual_max_slew_Tm_per_s is None: slew_ok = False; print(f"{print_prefix} Could not determine actual max slew rate.")
        elif max_slew_limit_Tm_per_s is not None:
            slew_ok = actual_max_slew_Tm_per_s <= max_slew_limit_Tm_per_s
            print(f"{print_prefix} Max Slew Rate: {actual_max_slew_Tm_per_s:.2f} T/m/s. Limit: {max_slew_limit_Tm_per_s:.2f} T/m/s. Status: {'OK' if slew_ok else 'EXCEEDED'}")
        else: print(f"{print_prefix} Max Slew Rate: {actual_max_slew_Tm_per_s:.2f} T/m/s. No runtime limit provided for slew rate.")

        if self.gen_max_grad_Tm_per_m is not None:
            print(f"{print_prefix} Note: Generator target max_grad was {self.gen_max_grad_Tm_per_m:.4f} T/m.")
        if self.gen_max_slew_Tm_per_s_per_m is not None:
            print(f"{print_prefix} Note: Generator target max_slew was {self.gen_max_slew_Tm_per_s_per_m:.2f} T/m/s.")

        return grad_ok and slew_ok

    def assess_kspace_coverage(self) -> str:
        return (f"Drunken Kooshball sequence '{self.name}'. This 3D trajectory provides stochastic, "
                "variable-density k-space coverage. It is designed to be denser towards the k-space center "
                f"(influenced by density_sigma_factor: {self.density_sigma_factor}) and promotes "
                "incoherent aliasing, which is advantageous for 3D Compressed Sensing.")

    def estimate_off_resonance_sensitivity(self) -> str:
        return (f"The '{self.name}' (3D Drunken Kooshball) trajectory involves extended readout segments similar "
                "to its 2D counterpart. This can lead to sensitivity to off-resonance effects, potentially "
                "causing diffuse, noise-like artifacts or blurring in 3D. The stochasticity might prevent highly "
                "structured artifacts seen in regular 3D spirals or cones.")

    def assess_motion_robustness(self) -> str:
        return (f"For '{self.name}', the dense sampling of central k-space regions is beneficial for motion robustness. "
                "Acquisition of the full 3D volume needs to be fast to mitigate motion effects "
                f"(total points: {self.num_points}, dt: {self.dt_seconds}s). The pseudo-random nature can make "
                "data-driven motion correction complex but also potentially more robust to certain types of motion "
                "if advanced reconstruction is used.")

    def suggest_reconstruction_method(self) -> str:
        return (f"3D Compressed Sensing (CS) is highly recommended for reconstructing data from the '{self.name}' "
                "Drunken Kooshball trajectory, leveraging its incoherent aliasing properties. A 3D NUFFT algorithm "
                "is essential for handling the non-Cartesian data. Iterative reconstruction methods incorporating "
                "sparsity transforms (e.g., wavelets) or other regularizers are typically required.")
```
