"""
Defines the DrunkenSpiralSequence class.
"""
from typing import Any, Dict, Optional, Tuple, Union

import numpy as np

from trajgen.generators import generate_drunken_spiral_trajectory
from trajgen.sequence_base import MRISequence
from trajgen.trajectory import COMMON_NUCLEI_GAMMA_HZ_PER_T

__all__ = ['DrunkenSpiralSequence']


class DrunkenSpiralSequence(MRISequence):
    """
    Represents a 2D "Drunken Spiral" k-space trajectory.

    This sequence is generated by perturbing a base spiral trajectory and then
    iteratively smoothing it to attempt to meet gradient and slew rate constraints.
    It's designed for pseudo-random, variable-density k-space coverage.
    """

    def __init__(self,
                 # Common MRISequence parameters (some are also for generator)
                 name: str,
                 fov_mm: Union[float, Tuple[float, float]],
                 resolution_mm: Union[float, Tuple[float, float]],
                 dt_seconds: float,
                 # Drunken Spiral specific parameters (also for generator)
                 num_points: int, # Total number of points for the trajectory
                 base_spiral_turns: float = 5.0,
                 perturbation_amplitude_factor: float = 0.1,
                 density_sigma_factor: float = 0.25,
                 max_grad_Tm_per_m: Optional[float] = None, # Target for generator
                 max_slew_Tm_per_s_per_m: Optional[float] = None, # Target for generator (T/m/s)
                 num_smoothing_iterations: int = 3,
                 smoothing_kernel_size: int = 5,
                 smoothness_emphasis_factor: Optional[float] = None, # New
                 # Other MRISequence parameters
                 gamma_Hz_per_T: float = COMMON_NUCLEI_GAMMA_HZ_PER_T['1H'],
                 dead_time_start_seconds: float = 0.0,
                 dead_time_end_seconds: float = 0.0,
                 metadata: Optional[Dict[str, Any]] = None):
        """
        Initializes a DrunkenSpiralSequence object.

        Args:
            name (str): Name of the sequence.
            fov_mm (Union[float, Tuple[float, float]]): Field of View in millimeters.
            resolution_mm (Union[float, Tuple[float, float]]): Desired resolution in millimeters.
            dt_seconds (float): Dwell time (time between k-space samples) in seconds.
            num_points (int): Total number of k-space points for the trajectory.
            base_spiral_turns (float): Number of turns for the underlying Archimedean spiral.
            perturbation_amplitude_factor (float): Factor scaling random noise amplitude.
            density_sigma_factor (float): Sigma for Gaussian weighting of noise (relative to k_max).
            max_grad_Tm_per_m (Optional[float]): Target maximum gradient for generator (T/m).
            max_slew_Tm_per_s_per_m (Optional[float]): Target maximum slew rate for generator (T/m/s).
            num_smoothing_iterations (int): Iterations for smoothing in generator.
            smoothing_kernel_size (int): Kernel size for smoothing in generator.
            smoothness_emphasis_factor (Optional[float]): Factor [0,1] to emphasize smoothness.
            gamma_Hz_per_T (float): Gyromagnetic ratio.
            dead_time_start_seconds (float): Dead time at sequence start.
            dead_time_end_seconds (float): Dead time at sequence end.
            metadata (Optional[Dict[str, Any]]): Additional metadata.
        """
        self.num_points = num_points # Specific to this sequence type's generation
        self.base_spiral_turns = base_spiral_turns
        self.perturbation_amplitude_factor = perturbation_amplitude_factor
        self.density_sigma_factor = density_sigma_factor
        self.gen_max_grad_Tm_per_m = max_grad_Tm_per_m # Store generator's target limits
        self.gen_max_slew_Tm_per_s_per_m = max_slew_Tm_per_s_per_m
        self.num_smoothing_iterations = num_smoothing_iterations
        self.smoothing_kernel_size = smoothing_kernel_size
        self.smoothness_emphasis_factor = smoothness_emphasis_factor # New

        sequence_specific_params = {
            'num_points': num_points,
            'base_spiral_turns': base_spiral_turns,
            'perturbation_amplitude_factor': perturbation_amplitude_factor,
            'density_sigma_factor': density_sigma_factor,
            'max_grad_Tm_per_m_target': max_grad_Tm_per_m,
            'max_slew_Tm_per_s_per_m_target': max_slew_Tm_per_s_per_m,
            'num_smoothing_iterations': num_smoothing_iterations,
            'smoothing_kernel_size': smoothing_kernel_size,
            'smoothness_emphasis_factor': smoothness_emphasis_factor, # New
        }

        num_dimensions = 2 # Drunken spiral as implemented is 2D

        super().__init__(
            name=name,
            fov_mm=fov_mm,
            resolution_mm=resolution_mm,
            num_dimensions=num_dimensions,
            dt_seconds=dt_seconds,
            gamma_Hz_per_T=gamma_Hz_per_T,
            sequence_specific_params=sequence_specific_params,
            dead_time_start_seconds=dead_time_start_seconds,
            dead_time_end_seconds=dead_time_end_seconds,
            metadata=metadata
        )

    def _generate_kspace_points(self) -> np.ndarray:
        """
        Generates k-space points for the Drunken Spiral sequence.
        The generator returns k-space points in rad/m with shape (2, N).
        """
        kspace_points_D_N = generate_drunken_spiral_trajectory(
            fov_mm=self.fov_mm,
            resolution_mm=self.resolution_mm,
            num_points=self.num_points,
            dt_seconds=self.dt_seconds, # From base Trajectory class
            base_spiral_turns=self.base_spiral_turns,
            perturbation_amplitude_factor=self.perturbation_amplitude_factor,
            density_sigma_factor=self.density_sigma_factor,
            max_grad_Tm_per_m=self.gen_max_grad_Tm_per_m,
            max_slew_Tm_per_s_per_m=self.gen_max_slew_Tm_per_s_per_m,
            gamma_Hz_per_T=self.metadata.get('gamma_Hz_per_T', COMMON_NUCLEI_GAMMA_HZ_PER_T['1H']),
            num_smoothing_iterations=self.num_smoothing_iterations,
            smoothing_kernel_size=self.smoothing_kernel_size,
            smoothness_emphasis_factor=self.smoothness_emphasis_factor # New
        )
        return kspace_points_D_N

    def check_gradient_limits(self, system_limits: Dict[str, Any]) -> bool:
        """
        Checks if the trajectory's actual gradient waveforms and slew rates are within
        the specified runtime system_limits.
        The generator already attempts to meet limits passed during __init__. This method
        provides a way to check against potentially different or more stringent limits.
        """
        max_grad_limit_Tm_per_m = system_limits.get('max_grad_Tm_per_m')
        # Assuming key in system_limits is 'max_slew_Tm_per_s_per_m' for T/m/s
        max_slew_limit_Tm_per_s = system_limits.get('max_slew_Tm_per_s_per_m')

        actual_max_grad_Tm = self.get_max_grad_Tm()
        actual_max_slew_Tm_per_s = self.get_max_slew_Tm_per_s()
        grad_ok, slew_ok = True, True
        print_prefix = f"Gradient Limit Check for '{self.name}':"

        if actual_max_grad_Tm is None: grad_ok = False; print(f"{print_prefix} Could not determine actual max gradient.")
        elif max_grad_limit_Tm_per_m is not None:
            grad_ok = actual_max_grad_Tm <= max_grad_limit_Tm_per_m
            print(f"{print_prefix} Max Gradient: {actual_max_grad_Tm:.4f} T/m. Limit: {max_grad_limit_Tm_per_m:.4f} T/m. Status: {'OK' if grad_ok else 'EXCEEDED'}")
        else: print(f"{print_prefix} Max Gradient: {actual_max_grad_Tm:.4f} T/m. No runtime limit provided for gradient.")

        if actual_max_slew_Tm_per_s is None: slew_ok = False; print(f"{print_prefix} Could not determine actual max slew rate.")
        elif max_slew_limit_Tm_per_s is not None:
            slew_ok = actual_max_slew_Tm_per_s <= max_slew_limit_Tm_per_s
            print(f"{print_prefix} Max Slew Rate: {actual_max_slew_Tm_per_s:.2f} T/m/s. Limit: {max_slew_limit_Tm_per_s:.2f} T/m/s. Status: {'OK' if slew_ok else 'EXCEEDED'}")
        else: print(f"{print_prefix} Max Slew Rate: {actual_max_slew_Tm_per_s:.2f} T/m/s. No runtime limit provided for slew rate.")

        # Add information about generator's target limits if they were set
        if self.gen_max_grad_Tm_per_m is not None:
            print(f"{print_prefix} Note: Generator target max_grad was {self.gen_max_grad_Tm_per_m:.4f} T/m.")
        if self.gen_max_slew_Tm_per_s_per_m is not None:
            print(f"{print_prefix} Note: Generator target max_slew was {self.gen_max_slew_Tm_per_s_per_m:.2f} T/m/s.")

        return grad_ok and slew_ok

    def assess_kspace_coverage(self) -> str:
        return (f"Drunken Spiral sequence '{self.name}'. This trajectory offers pseudo-random, "
                "variable-density k-space coverage. It's typically denser at the k-space center "
                f"(due to density_sigma_factor: {self.density_sigma_factor}) and designed to "
                "provide incoherent aliasing, which is beneficial for compressed sensing.")

    def estimate_off_resonance_sensitivity(self) -> str:
        return (f"The '{self.name}' trajectory, while not a pure spiral, retains spiral-like characteristics "
                "with extended readout segments. This can lead to some sensitivity to off-resonance effects, "
                "potentially causing blurring or distortions. The stochastic nature might make these artifacts "
                "less structured or coherent than those from regular spirals.")

    def assess_motion_robustness(self) -> str:
        return (f"For '{self.name}', the dense sampling of the k-space center can be advantageous for motion robustness, "
                "similar to other variable-density trajectories. However, the pseudo-random, non-repeating nature "
                "of the trajectory might make simple, data-driven motion correction complex. "
                f"Acquisition speed (total points: {self.num_points}, dt: {self.dt_seconds}s) "
                "is the primary factor for mitigating motion effects by reducing scan time.")

    def suggest_reconstruction_method(self) -> str:
        return (f"Compressed Sensing (CS) is strongly recommended for reconstructing data from the '{self.name}' "
                "trajectory due to its incoherent undersampling properties. A NUFFT algorithm is a necessary "
                "component for handling the non-Cartesian data within the CS framework. Iterative reconstruction "
                "algorithms that can incorporate sparsity or other regularizers are typically used.")
```
